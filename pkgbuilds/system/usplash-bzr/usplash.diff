=== modified file 'usplash.c'
--- usplash.c	2008-05-22 16:35:15 +0000
+++ usplash.c	2008-12-20 15:52:19 +0000
@@ -24,6 +24,8 @@
 #include <sys/select.h>
 #include <sys/time.h>
 #include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 
@@ -43,10 +45,19 @@
 #include "usplash.h"
 #include "libusplash.h"
 
+#define MAX_CONNECTIONS 5
+
+struct ucred {
+	pid_t pid;
+	uid_t uid;
+	gid_t gid;
+};
+
 static int main_loop(void);
-static int read_command(void);
+static int read_command(int socknum);
 static int parse_command(const char *string, size_t len);
 static void do_animate(int ignore);
+static int setnonblocking(int s);
 
 /* Number of seconds to wait for a command before exiting */
 static int timeout = 15;
@@ -57,8 +68,9 @@
 static int cycles = 0;
 static int cycle_timeout = 375;
 
-static int fifo_fd;
-
+/* static int fifo_fd; */
+static int sock;
+static int sockets[MAX_CONNECTIONS];
 
 int main(int argc, char *argv[])
 {
@@ -69,6 +81,7 @@
 	struct timeval t1 = {.tv_sec = 0,.tv_usec = 40000 };
 	struct timeval t2 = {.tv_sec = 0,.tv_usec = 40000 };
 	struct itimerval iv = {.it_interval = t1,.it_value = t2 };
+	struct sockaddr sock_addr = {AF_UNIX, USPLASH_SOCKET};
 
 	for (i = 1; i < argc; i++) {
 		if (!strcmp(argv[i], "-c")) {
@@ -88,37 +101,28 @@
 		}
 	}
 
-	if (chdir(USPLASH_DIR) < 0) {
-		perror("chdir");
-		ret = 1;
-		goto exit;
-	}
-
-	if (mkfifo(USPLASH_FIFO, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) <
-	    0) {
-		if (errno != EEXIST) {
-			perror("mkfifo");
-			ret = 1;
-			goto exit;
-		}
-	}
-
-	if (mkfifo(USPLASH_OUTFIFO, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)
-	    < 0) {
-		if (errno != EEXIST) {
-			perror("mkfifo");
-			ret = 1;
-			goto exit;
-		}
-	}
-
-	/* open as writable too so that select() never sees EOF */
-	fifo_fd = open(USPLASH_FIFO, O_RDWR | O_NONBLOCK);
-	if (fifo_fd < 0) {
-		perror("open");
-		ret = 2;
-		goto exit;
-	}
+	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {
+		perror("socket");
+		ret = 1;
+		goto exit;
+	}
+
+	if (bind(sock, &sock_addr, sizeof(sock_addr)) < 0) {
+		perror("bind");
+		ret = 1;
+		goto exit;
+	}
+
+	if (listen(sock, MAX_CONNECTIONS) < 0) {
+		perror("listen");
+		ret =1;
+		goto exit;
+	}
+
+	setnonblocking(sock);
+
+	for(i = 0; i < MAX_CONNECTIONS; i++)
+		sockets[i] = -1;
 
 	if (usplash_setup(xres, yres, verbose)) {
 		fprintf(stderr, "screen init failed\n");
@@ -154,24 +158,87 @@
 	animate_step(pulsating);
 }
 
+
+static int setnonblocking(int s)
+{
+	int flags;
+	
+	if((flags = fcntl(s, F_GETFL)) < 0) {
+		perror("F_GETFL");
+		return -1;
+	}
+
+	if((fcntl(s, F_SETFL, flags | O_NONBLOCK)) < 0) {
+		perror("F_SETFL");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void handle_new_connection(void)
+{
+	int fd, i;
+	struct ucred cred;
+	socklen_t cred_len = sizeof(cred);
+
+	fd = accept(sock, NULL, NULL);
+	if(fd < 0) {
+		perror("accept");
+		return;
+	}
+
+	if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cred, &cred_len) < 0) {
+		close(fd);
+		perror("GETSOCKOPT");
+		return;
+	}
+
+	if (cred.uid != 0) {
+		close(fd);
+		return;
+	}
+
+
+	for(i=0; i<MAX_CONNECTIONS; i++) {
+		if(sockets[i] == -1) {
+			sockets[i] = fd;
+			setnonblocking(fd);
+			break;
+		}
+	}
+
+	if(i == MAX_CONNECTIONS)
+		close(fd);
+}
+
 static int main_loop(void)
 {
 	struct timeval tv;
+	int i, retval, ret, sock_max;
+	fd_set rfds;
 
 	for (;;) {
-		fd_set rfds;
-		int retval;
-
 		FD_ZERO(&rfds);
-		FD_SET(fifo_fd, &rfds);
+		FD_SET(sock, &rfds);
+		sock_max = sock;
+
+		for(i = 0; i < MAX_CONNECTIONS; i++) {
+			if(sockets[i] != -1) {
+				FD_SET(sockets[i], &rfds);
+				if(sockets[i] > sock_max)
+					sock_max = sockets[i];
+			}
+		}
 
 		tv.tv_sec = timeout ? timeout : 1;
 		tv.tv_usec = 0;
 
-		retval = select(fifo_fd + 1, &rfds, NULL, NULL, &tv);
+		retval = select(sock_max + 1, &rfds, NULL, NULL, &tv);
 
 		if (retval < 0 && errno != EINTR) {
 			/* Error */
+			perror("select");
 			return 1;
 		} else if (retval < 0 && errno == EINTR) {
 			/* Count cycles for timeout */
@@ -179,12 +246,19 @@
 			if (cycle_timeout && cycles >= cycle_timeout)
 				return 0;
 		} else if (retval > 0) {
-			/* Data available */
-			int ret;
+			/* New connection */
+			if(FD_ISSET(sock, &rfds))
+				handle_new_connection();
+
+			for(i = 0; i < MAX_CONNECTIONS; i++) {
+				if(sockets[i] != -1 && FD_ISSET(sockets[i], &rfds)) {
+					ret = read_command(i);
+					if(ret)
+						return ret;
+				}
+			}
+
 			cycles = 0;
-			ret = read_command();
-			if (ret)
-				return ret;
 		}
 	}
 
@@ -192,38 +266,29 @@
 	return 0;
 }
 
-static int read_command(void)
+
+static int read_command(int socknum)
 {
 	static char buf[PIPE_BUF], *ptr;
 	static size_t buflen;
 	static ssize_t len;
 
-	len = read(fifo_fd, buf + buflen, sizeof(buf) - buflen);
+	len = read(sockets[socknum], buf, sizeof(buf));
+	
 	if (len < 0) {
-		/*
-		 * EAGAIN is allowed due to O_NONBLOCK
-		 * EINTR is allowed in the case of signal delivery
-		 */
 		if (errno != EAGAIN && errno != EINTR) {
-			/* Try opening again */
-			close(fifo_fd);
-			fifo_fd =
-			    open(USPLASH_FIFO, O_RDWR | O_NONBLOCK);
-			if (fifo_fd < 0)
-				return 2;
+			close(sockets[socknum]);
+			sockets[socknum] = -1;
 		}
 
 		return 0;
 	} else if (len == 0) {
-		/*
-		 * 0 length return on an O_NONBLOCK fifo means there are
-		 * no more writers.  This should never happen since we our
-		 * ourselves a writer (so select doesn't spam us when there
-		 * are no other writers).
-		 */
 		return 2;
 	}
 
+	close(sockets[socknum]);
+	sockets[socknum] = -1;
+
 	buflen += len;
 	while ((ptr = memchr(buf, '\0', buflen)) != NULL) {
 		int ret;
@@ -240,6 +305,7 @@
 	return 0;
 }
 
+
 static int parse_command(const char *string, size_t len)
 {
 	const char *command;

=== modified file 'usplash.h'
--- usplash.h	2006-09-24 13:19:47 +0000
+++ usplash.h	2008-12-20 15:49:31 +0000
@@ -21,6 +21,9 @@
 #ifndef USPLASH_H
 #define USPLASH_H
 
+/* Name of the Unix Socket */
+#define USPLASH_SOCKET "\0usplash"
+
 /* Directory of usplash control fifo */
 #define USPLASH_DIR   "/dev/.initramfs"
 
=== modified file 'usplash_write.c'
--- usplash_write.c	2008-07-28 14:50:44 +0000
+++ usplash_write.c	2008-12-20 15:51:20 +0000
@@ -22,6 +22,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/socket.h>
 
 #include <errno.h>
 #include <fcntl.h>
@@ -36,50 +37,38 @@
 
 int main(int argc, char *argv[])
 {
-	int i, fifo_fd;
+	int i, sock;
+	struct sockaddr sock_addr = {AF_UNIX, USPLASH_SOCKET};
 
 	if (argc < 2) {
 		fprintf(stderr, "Usage: usplash_write COMMAND...\n");
 		exit(1);
 	}
 
-	if (chdir(USPLASH_DIR) < 0) {
-		if (errno != ENOENT)
-			perror("chdir");
-		exit(0);
+	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {
+		perror("sock");
+		return 1;
 	}
 
-	fifo_fd = open(USPLASH_FIFO, O_WRONLY | O_NONBLOCK);
-	if (fifo_fd < 0) {
-		/*
- 		 * Don't perror on EACCES, as this causes noise in init scripts
- 		 * run by non-privileged users.
-		 */
-		if ((errno != ENXIO) && (errno != ENOENT) && (errno != EACCES))
-			perror("open");
-		exit(getenv("FAIL_NO_USPLASH") ? 1 : 0);
+	if (connect(sock, &sock_addr, sizeof(sock_addr)) < 0) {
+		perror("connect");
+		return 1;
 	}
 
 	for (i = 1; i < argc; i++) {
 		size_t argsize;
 		ssize_t len;
 
-		/*
-		 * POSIX says writes to a fifo larger than PIPE_BUF could
-		 * get interleaved, so we must truncate those.
-		 */
 		argsize = strlen(argv[i]);
-		if (argsize + 1 > PIPE_BUF) {
-			argsize = PIPE_BUF - 1;
-			argv[i][argsize] = '\0';
-		}
 		
-		len = write(fifo_fd, argv[i], argsize + 1);
-		if (len < 0) {
+		len = write(sock, argv[i], argsize + 1);
+		if (len <= 0) {
 			perror("write");
 			exit(0);
 		}
 	}
 
+	close(sock);
+
 	return 0;
 }

